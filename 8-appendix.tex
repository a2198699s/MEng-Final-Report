\chapter{Appendix Items}


%\colorlet{keyword}{blue!100!black!80}
%\colorlet{comment}{green!90!black!90}


% code formatting
\definecolor{maroon}{rgb}{0.5,0,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{codegreen}{rgb}{0,0.26,0.14}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{codepurple},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{maroon},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}



\section{Input Position Translation Code} % reference in verification and design
\label{position-multiplexing-code}
Implementation code example showing the input position translation from the button inputs into an understood position format
\begin{lstlisting}[language=VHDL]
	input_multiplexing : process(rst_i, clk_i) 
	begin
		if (rst_i = '0') then
			position_in_s     <= POSITION_0;
			buttons_read_in_s <= (others => '0'); 
		elsif rising_edge(clk_i) then
			buttons_read_in_s <= ca_3_s & not n_ca_3_s & ca_4_s & not n_ca_4_s 
			    & ca_5_s & not n_ca_5_s & ca_6_s & not n_ca_6_s;
			if (buttons_read_in_s = BUTTONS_POS_0) then
				position_in_s <= POSITION_0;
			elsif (buttons_read_in_s = BUTTONS_POS_1) then
				position_in_s <= POSITION_1;
			elsif (buttons_read_in_s = BUTTONS_POS_2) then
				position_in_s <= POSITION_2;
			elsif (buttons_read_in_s = BUTTONS_POS_1_0) then
				position_in_s <= POSITION_1_0;
			elsif (buttons_read_in_s = BUTTONS_POS_2_0) then
				position_in_s <= POSITION_2_0;
			elsif (buttons_read_in_s = BUTTONS_POS_0_FROM_1) then
				position_in_s <= POSITION_0_FROM_1;
			elsif (buttons_read_in_s = BUTTONS_POS_0_FROM_2) then
				position_in_s <= POSITION_0_FROM_2;
			else
				position_in_s <= INVALID_POSITION;
			end if;
		end if;
	end process input_multiplexing;
\end{lstlisting}


\section{Input Processing Code}
\label{input-processing-code}
Implementation code example showing the launch control process and the direction and movement determination

\begin{lstlisting}[language=VHDL]
input_processing : case Launch_State is
				when WAIT_STATE =>
					if (cmd_ready_i = '1') then
						command_in_s <= command_i;
						Launch_State <= INPUT_ACQUISITION;
					else
						Launch_State <= WAIT_STATE;
					end if;
				when INPUT_ACQUISITION => 
					if (command_in_s = RETURN_TO_0) then
						return_to_zero_flag_s <= '1';
					end if;
					current_position_s <= 
					        position_i(3 downto 2);
					position_desired_s <= 
					        command_in_s(POSITION_ENCODING_WIDTH - 1 downto 0);
					relative_position_s <= 
					        position_i(POSITION_ENCODING_WIDTH - 1 downto 0);
					Launch_State <= CALCULATE_MOVEMENT;
				when CALCULATE_MOVEMENT =>
					if (command_in_s = RETURN_TO_0) then
						return_to_zero_flag_s <= '1';
					end if;
					if (position_desired_s < current_position_s) 
					    or (position_desired_s = current_position_s 
					    and relative_position_s = RIGHT_OF_POSITION) then
						direction_o       <= RIGHT_MOVE;
						next_position_i_s <= position_desired_s & ACTUAL_POSITION;
						Launch_State      <= MOVE;
					elsif (position_desired_s > current_position_s)
					    or (position_desired_s = current_position_s 
					    and relative_position_s = LEFT_OF_POSITION) then
						direction_o       <= LEFT_MOVE;
						next_position_i_s <= position_desired_s & ACTUAL_POSITION;
						Launch_State      <= MOVE;
					else
						Launch_State <= RETURN_TO_ZERO_CHECK;
					end if;
				when MOVE =>
					move_required_i_s <= '1';
					if (error_o_s = '1') then
						Launch_State <= ERROR;
					elsif (position_reached_o_s = '1') then
						move_required_i_s <= '0';
						Launch_State      <= INPUT_ACQUISITION;
					end if;
				when RETURN_TO_ZERO_CHECK =>
					if (return_to_zero_flag_s = '1') then
						Launch_State <= ERROR;
					else
						Launch_State <= WAIT_STATE;
					end if;
				when ERROR =>           
					Launch_State <= ERROR;
					error_o <= '1';
			end case state_transitions;
\end{lstlisting}



\section{ADC Multiplexor Harness Code}
\label{adc-multiplexing-code}
Implementation code example showing the multiplexor harness used to control the ADC measurements

\begin{lstlisting}[language=VHDL]
case Adc_State is
				-- measuring current 
				when CURRENT_CALC1 =>
					rst_internal        <= '0';
					delta_i             <= analog_current_i;
					Adc_State <= CURRENT_CALC2;
				when CURRENT_CALC2 =>
					rst_internal <= '1';
					delta_i      <= analog_current_i;
					if (stop_mc_i = '1') then
						Adc_State <= VOLTAGE_CALC1;
					elsif (sample_rdy_s = '1') then
						motor_current_o     <= digital_out_i; -- input topology 0
					end if;
				-- measuring voltage 
				when VOLTAGE_CALC1 =>
					rst_internal        <= '0';
					delta_i             <= analog_voltage_i;
					Adc_State <= VOLTAGE_CALC2;
				when VOLTAGE_CALC2 =>
					rst_internal <= '1';
					delta_i      <= analog_voltage_i;
					if (start_mc_i = '1') then 
						Adc_State <= CURRENT_CALC1;
					elsif (sample_rdy_s = '1') then 
						supply_voltage_o    <= not digital_out_i; -- input topology
					end if;
			end case;

\end{lstlisting}



\section{PWM Regulation Code}
\label{pwm-regulation-code}
Implementation code example showing the PWM regulation process

\begin{lstlisting}[language=VHDL]
			if (en_regulation_i = '1') then
				current_error_s    := to_integer(unsigned(NOMINAL_CURRENT)) 
				    - to_integer(unsigned(current_hold_i));
				duty_cycle_error_s := current_error_s / 2; -- K gain
				duty_cycle_o_s := to_integer(set_pwm_i) /2 + duty_cycle_error_s; 
				if (duty_cycle_o_s < to_integer(PWM_MIN_VALUE)) then
					duty_cycle_o <= PWM_MIN_VALUE;
				elsif (remove_limit_i = '1') then
					if (duty_cycle_o_s > to_integer(PWM_MAX)) then
						duty_cycle_o <= PWM_MAX;
					else
						duty_cycle_o <= to_std_logic_vector(duty_cycle_o_s, 
						        PWM_RESOLUTION);
					end if;
				elsif (duty_cycle_o_s > to_integer(set_pwm_i)) then
					duty_cycle_o <= set_pwm_i;
				else
					duty_cycle_o <= to_std_logic_vector(duty_cycle_o_s, 
					        PWM_RESOLUTION);
				end if;
			else
				duty_cycle_o <= set_pwm_i;
			end if;
\end{lstlisting}




\section{IGBT Driving Code}
\label{igbt-driving-code}
Implementation code example showing the IGBT driving process of the motor driving module
\begin{lstlisting}[language=VHDL]
igbt_driving : process (rst_i, clk_i)
		begin
		if (rst_i = '0') then
			pwm_db_o <= '0';
			en_db_o <= '0';
			pwm_gb_o <= '0';
			en_gb_o <= '0';
		elsif rising_edge(clk_i) then
			if (brake_i = '1') then
				pwm_db_o <= '1'; 
				en_db_o <= '1'; 
				pwm_gb_o <= '1'; 
				en_gb_o <= '1';
			elsif (pwm_enable_i = '1' and direction_i = LEFT_MOVE) then
				pwm_db_o <= '0';
				en_db_o <= '0';	
				pwm_gb_o <= pwm_i;
				en_gb_o <= '1';
			elsif (pwm_enable_i = '1' and direction_i = RIGHT_MOVE) then
				pwm_db_o <= pwm_i;
				en_db_o <= '1';			
				pwm_gb_o <= '0';
				en_gb_o <= '0';	
			elsif (pwm_full_i = '1' and direction_i = LEFT_MOVE) then
				pwm_db_o <= '0';
				en_db_o <= '0';	
				pwm_gb_o <= '1';
				en_gb_o <= '1';
			elsif (pwm_full_i = '1' and direction_i = RIGHT_MOVE) then
				pwm_db_o <= '1';
				en_db_o <= '1';			
				pwm_gb_o <= '0';
				en_gb_o <= '0';		
			else
				pwm_db_o <= '0';
				en_db_o <= '0';			
				pwm_gb_o <= '0';
				en_gb_o <= '0';								
			end if;
		end if;
	end process igbt_driving;
\end{lstlisting}

\section{PWM Control State Machine Code} % reference in verification and design
\label{pwm-state-machine-code}
Implementation code example showing the PWM control state machine phases and transition conditions

\begin{lstlisting}[language=VHDL]
pwm_state_machine : case PWM_State is
				when PWM_MIN =>
					set_pwm_o_s <= PWM_MIN_VALUE;
					en_regulation_o <= '0';
					if (pwm_increase_i = '1') then
						pwm_max_value_s <= top_pwm_i;
						PWM_State       <= PWM_INCREASE;
					else
						PWM_State <= PWM_MIN;
					end if;
				when PWM_INCREASE =>
					en_regulation_o <= '0';
					if (brake_i = '1') then
						PWM_State <= PWM_MIN;
					elsif (set_pwm_o_s >= pwm_max_value_s) then
						set_pwm_o_s <= pwm_max_value_s; 
						PWM_State   <= PWM_REGULATION;
					else
						if (increase_flag = '1') then 
							set_pwm_o_s <= set_pwm_o_s + PWM_INCREASE_CONSTANT;
						end if;
						PWM_State <= PWM_INCREASE;
					end if;
				when PWM_REGULATION =>
					en_regulation_o <= '1'; 
					if (brake_i = '1') then
						PWM_State <= PWM_MIN;
					end if;
			end case pwm_state_machine;
\end{lstlisting}


\section{Position Module UVVM Verification Code}
\label{UVVM_Position_Code}
Verification code example showing the application of UVVM to simulate, verify and test the Position sub-module
\begin{lstlisting}[language=VHDL]
position_inputs_s <= in_position_1;
await_value(output_position_s, POSITION_1, 
            0 * C_CLK_PERIOD, 10 * C_CLK_PERIOD, 
            WARNING, "Waiting for position update");
wait for (15 * C_CLK_PERIOD);
check_value(output_position_s, POSITION_1, 
            WARNING, "Check output is position 1");
check_stable(output_position_s, 
            10 * C_CLK_PERIOD, 
            WARNING, "Checking output is stable");
\end{lstlisting}



\section{Motor Control Module OSVVM State-Transitionin Code}
\label{OSVVM_Motor_Bins}
Verification code example showing the mapping of state transitions for automatic OSVVM simulation coverage

\begin{lstlisting}[language=VHDL]
test_FSM_CP.AddCross("Transition from Wait State to Thyristor Startup",
                    GenBin(Motor_Control_State'POS(WAIT_STATE)),
                    GenBin(Motor_Control_State'POS(THYRISTOR_STARTUP)));
test_FSM_CP.AddCross("Transition from Thyristor Startup to PWM Startup",
                    GenBin(Motor_Control_State'POS(THYRISTOR_STARTUP)), 
                    GenBin(Motor_Control_State'POS(PWM_STARTUP)));
test_FSM_CP.AddCross("Transition from PWM Startup to PWM Increase",
                    GenBin(Motor_Control_State'POS(PWM_STARTUP)),
                    GenBin(Motor_Control_State'POS(PWM_INCREASE)));
test_FSM_CP.AddCross("Transition from PWM Startup to Brake",
                    GenBin(Motor_Control_State'POS(PWM_STARTUP)), 
                    GenBin(Motor_Control_State'POS(BRAKE)));
test_FSM_CP.AddCross("Transition from PWM Increase to PWM Regulation", 
                    GenBin(Motor_Control_State'POS(PWM_INCREASE)), 
                    GenBin(Motor_Control_State'POS(PWM_REGULATION)));
test_FSM_CP.AddCross("Transition from PWM Increase to Brake", 
                    GenBin(Motor_Control_State'POS(PWM_INCREASE)), 
                    GenBin(Motor_Control_State'POS(BRAKE)));
test_FSM_CP.AddCross("Transition from PWM Regulation to Brake", 
                    GenBin(Motor_Control_State'POS(PWM_REGULATION)), 
                    GenBin(Motor_Control_State'POS(BRAKE)));
test_FSM_CP.AddCross("Transition from Brake to No Command", 
                    GenBin(Motor_Control_State'POS(BRAKE)), 
                    GenBin(Motor_Control_State'POS(NO_CMD)));
test_FSM_CP.AddCross("Transition from No Command to Wait State", 
                    GenBin(Motor_Control_State'POS(NO_CMD)),    
                    GenBin(Motor_Control_State'POS(WAIT_STATE)));
\end{lstlisting}